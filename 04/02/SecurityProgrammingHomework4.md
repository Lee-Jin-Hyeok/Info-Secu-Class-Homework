### 성공적인 코딩 인터뷰를 위한 코딩 인터뷰 정복하기 – 코딩 테스트

## Section 4. 자료구조, 알고리즘

#### 1. 큐 (Queue)

- 큐는 가장 먼저 들어간 자료가 가장 먼저 나간다는 FIFO를 구현한 자료구조이다.
  큐의 삽입 명령어는 Enqueue이며 삭제(리턴) 명령어는 Dequeue 이다.
- 큐는 일상생활에서는 줄서기와 같은 것을 예로 들 수 있고,
  컴퓨터 상에서는 CPU 스케쥴러나 프린터기에서 볼 수 있다.

#### 2. 스택 (Stack)

- 스택은 가장 마지막에 들어간 자료가 가장 먼저 나간다는 LIFO를 구현한 자료구조이다.
  스택의 삽입 명령어는 Push이며 삭제(리턴) 명령어는 Pop 이다.
- 스택은 삽입할 때 스택의 최대 용량을 넘어서 저장할 수 없기 때문에
  삽입시, 최대 용량을 넘어간 경우에 Stack Overflow를 발생시킨다.
- 스택은 스택이 비어있을 때 삭제 연산을 실행할 시 Stack Underflow를 발생시킨다.
- 스택은 일상생활에서는 쌓여있는 책에 비유할 수 있고
  컴퓨터 상에서는 브라우저의 되돌리기 버튼을 예로 들 수 있다.

#### 3. 링크드리스트 (Linked List)

- 링크드리스트는 값과 다음 노드를 지정할 수 있는 '노드'라는 것을 연결한 자료구조라고 할 수 있다.
  링크드리스트에는 Add, Remove, Print, Reverse와 같은 명령어가 기본적으로 존재한다.
- Add 명령어는 링크드리스트에 새로운 노드를 추가하는 역할을 한다. 즉, 삽입 연산을 진행하는 명령어이다.
  Remove 명령어는 링크드리스트에 노드를 삭제하는 역할을 한다. 즉, 삭제 연산을 진행하는 명령어이다.
  Print 명령어는 링크드리스트에 임의의 변수를 이용하여 노드의 첫 번째 값부터 가리키기 시작해서
  마지막 값까지 모두 출력하는 명령어이다.
  Reverse 명령어는 링크드리스트의 순서를 뒤바꾸는 명령어이며 임의의 변수를 이용해 진행한다.

#### 4. 힙 정렬 알고리즘 (Heap Sort)

- 힙 정렬 알고리즘은 트리 중에 하나이며 힙 정렬 알고리즘에서 사용되는 트리를 힙 트리(Heap Tree)라고 한다.
  힙 트리는 Max Heap과 Min Heap이 존재하는데,
  Max Heap은 부모의 노드가 자식의 노드보다 항상 값이 큰 힙 트리를 말하고,
  Min Heap은 부모의 노드가 자식의 노드보다 항상 값이 작은 힙 트리를 말한다.
- 힙 정렬 알고리즘에는 두 가지 명령어가 존재하는데
  Heapify와 Sift Down이 있다.
  Heapify는 일반 이진트리를 힙 트리로 변경하는 과정을 실행하는 명령어로서,
  자식 노드가 존재하는 노드부터 시작하고 순회하면서 Max Heap이면 자식의 노드의 값보다
  부모의 노드의 값이 더 크도록 설계하는 명령어이다.
  Sift Down은 Heapify 명령어 안에 존재하며 부모 노드와 자식 노드의 값을 비교하는 명령어이다.
- 힙 정렬 알고리즘은 시간 복잡도 O(n log n)을 가지며
  특히, Max Heap에서의 가장 큰값, Min Heap에서의 가장 작은 값을 구하는 데에는
  최상위 노드의 값을 알면 되기 때문에 O(1)의 최단 시간이 걸리는 알고리즘이다.
  공간 복잡도가 필요없다는 특징도 가지고 있다.

#### 5. 이진트리 알고리즘 (Binary Search Tree)

- 이진트리 알고리즘은 노드는 자식노드를 최대 두 개를 가질 수 있는 이진 트리에서
  왼쪽 자식노드는 부모 노드의 값보다 항상 작고, 오른쪽 자식노드는 부모 노드의 값보다 항상 큰 성질을
  가지는 알고리즘이다.
- 이진트리 알고리즘의 노드는 값을 저장할 변수와 왼쪽 자식노드를 가리킬 포인터, 오른쪽 자식노드를
  가리킬 포인터를 가지고 있다.
- 이진트리 알고리즘의 기본 명령어는 Add, Search, Remove가 있다.
- Add 명령어는 삽입하고자 하는 값과 최상위 노드부터 비교하여 최상위 노드보다 작으면
  왼쪽 자식노드로, 크면 오른쪽 자식노드로 가서 또 비교를 하면서 이동한 곳이 null이라면
  그곳에 새로운 노드를 만들어 삽입하고자 하는 값을 저장하고 이진트리에 삽입하는 명령어이다.
- Search 명령어는 내가 찾고자하는 값과 최상위 노드부터 비교하여 삽입과 동일하게 비교한 뒤
  찾고자하는 값이 있으면  true를 찾고자 하는 값이 없다면 false를 리턴하는 명령어이다.
- Remove 명령어는 삭제하고자 하는 값을 최상위 노드부터 비교하여 찾아서 삭제하게 되는데
  Remove 명령어시 삭제하는 노드가 자식노드가 없을 경우에는 그냥 삭제를하고
  자식노드가 한 개만 존재할 경우에는 그 자식노드로 삭제한 노드를 대체하며
  자식노드가 두 개일 경우에는 오른쪽 자식노드의 가장 왼쪽 자식노드
  또는 왼쪽 자식노드의 가장 오른쪽 자식노드로 삭제한 노드를 대체한다.
- 이진트리 알고리즘에서 이진트리를 순회하면서 돌 수 있는데 그 순회에는 세 가지 방법이 존재한다.
- 첫 번째 순회 방법은 전위 순회 방법인데 영어로는 Pre Order Traverse라고 한다.
  전위 순회 방법은 최상위 노드부터 시작해서 순회를 하게 되는데
  최상위 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드 순으로 순회를 한다.
  만약 자식 노드의 자식노드가 존재할 경우에는 또 다시 재귀적으로 실행한다.
  전위 순회 방법은 서버간의 통신할 때 트리 구조를 그대로 보낼 때 사용한다.
  이러면 트리 구조가 원래 상태로 복원될 뿐만 아니라 복원하면서 필요한 불필요한 연산이 줄게 된다.
- 두 번째 순회 방법은 중위 순회 방법인데 영어로는 In Order Traverse라고 한다.
  중위 순회 방법은 가장 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드 순으로 순회한다.
  중위 순회 방법대로 순회하게 되면 오름차순으로 정렬된 것을 볼 수 있다.
- 세 번째 순회 방법은 후위 순회 방법인데 영어로는 Post Order Traverse라고 한다.
  후위 순회 방법은 가장 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드 순으로 순회한다.
  따라서 최상위 노드가 가장 마지막에 오는 것을 알 수 있다.

#### 6. 그래프 (Graph)

- 정점(Vertex)과 간선(Edge)의 관계가 존재하는 것을 그래프라고 한다. (트리도 그래프의 종류이다.)

- Direct Graph는 정점과 간선이 있을 때 간선에게 방향이 주어진 그래프를 Direct Graph라고 한다.Undirect Graph는 정점과 간선이 있을 때 간선에게 방향이 없는 그래프를 Undirect Graph라고 한다.
  Weighted Graph는 정점과 간선이 있는데 간선에 가중치가 존재하는 그래프를 Weighted Graph라고 한다.
  Vertex List는 그래프의 정점에 존재하는 값을 리스트 형태로 존재하는 것을 Vertex List라고 하는데
  정점의 값이 1, 2, 3, 4가 있을 때 [ 1, 2, 3, 4 ] 와 같이 존재하는 것을 말한다.
  Edge List는 그래프의 정점에 존재하는 값 두 개를 이은 간선을 리스트에 포함한 것을 Edge List라고 하는데
  정점의 값이 1과 2가 연결되어 있고 2와 3이 연결되어 있을 때 [ (1, 2), (2, 3) ]과 같이 존재하는 것을 말한다.
  Adjacency List는 정점에게 각각의 인덱스를 주어주고 그 인덱스와 연결되어 있는 정점들을 리스트에
  넣은 리스트라고 할 수 있다.
  0, 1, 2, 3, 4가 있고 각각의 연결을 Adjacency List로 표현하면

  ```java
  [
      [1],
      [0, 2, 3],
      [1],
      [1, 4],
      [3]
  ]
  ```

  위와 같이 표현할 수 있고 이는 정점 0은 1과 연결되어 있고 정점 3은 1과 연결되어 있다는 것을 뜻한다.
  Adjacency Matrix는 정점간에 연결이 되어 있는지 확인할 수 있는 표를 말한다.
  A와 B는 연결되어 있고 B와 C는 연결되어 있지만 C와 A는 연결되어 있지 않을 때 다음과 같이 나타낼 수 있다.

  |       | A    | B    | C    |
  | ----- | ---- | ---- | ---- |
  | **A** | 0    | 1    | 0    |
  | **B** | 1    | 0    | 1    |
  | **C** | 0    | 1    | 0    |

  1은 연결되어 있다는 뜻이고 0은 연결되지 않았다는 뜻이며 같은 A끼리는 0을 유지한다.

#### 7. 깊이 우선 탐색 (DFS - Depth First Search)

- 깊이 우선 탐색은 그래프와 그의 인접 리스트, 그리고 스택을 이용해서 구현할 수 있다.
  깊이 우선 탐색은 임의의 정점을 고르는 것으로부터 시작된다.
  임의의 정점을 고른 후 그 정점을 스택에 넣는다.
  처음 넣은 정점은 스택에서 바로 빼내서 현재의 노드를 지정하는 current라는 저장공간에 넣어준다.
  current에 존재하는 정점과 연결된 정점들을 인접 리스트를 통해 확인한 후 스택에 넣는다.
  (이 때 이미 방문한 정점은 포함하지 않는다.)
  current에 존재하는 정점과 연결된 모든 정점을 스택에 push했으므로 current에 존재하는 정점을 제거하고
  깊이 우선 탐색의 결과물이 될 리스트에 저장한다.
  current가 비었으니 스택에서 pop하여 그 값을 current에 저장하고 이를 계속 반복한다.

  current가 비었으니 스택에서 pop하여 그 값을 current에 저장하고 이를 계속 반복한다.

- 위 과정을 통해서 깊이 우선 탐색을 할 수 있는데
  깊이 우선 탐색은 이름과 같이 한 곳만 먼저 쭉 판 후 찾고 다른 곳을 또 쭉 판 후 찾는다.

- 깊이 우선 탐색을 이용하면 그래프에 루프가 존재하는지 알 수 있는데
  그것은 깊이 우선 탐색을 하고 나온 결과물에 같은 정점의 값이 있는지 확인하는 것이다.
  만약 같은 정점의 값이 존재한다면 그것은 루프가 있다는 증거가 된다.

#### 8. 너비 우선 탐색 (BFS - Breadth First Search)

- 너비 우선 탐색은 그래프와 그의 인접 리스트 그리고 큐를 이용해서 구현할 수 있다.
  깊이 우선 탐색과 다른 점은 스택 대신 큐를 이용한다는 점이다.
  너비 우선 탐색도 깊이 우선 탐색과 마찬가지로 임의의 정점을 고르는 것으로 부터 시작된다.
  그 임의의 정점을 고른 후 그 정점을 큐에 넣는다.
  처음 넣은 정점은 큐에서 바로 빼내서 current 공간에 넣는다.
  current에 있는 정점과 연결되어 있는 정점들을 큐에 넣는다.
  모든 정점들을 큐에 넣었다면 current에 있는 정점을 너비 우선 탐색의 결과물이 될 리스트에 저장한다.
  그럼 current가 비었으므로 큐에서 dequeue하여 current에 저장하고 이를 반복한다.
- 위 과정을 통해서 너비 우선 탐색을 할 수 있다.
  깊이 우선 탐색은 한 곳을 먼저 파고 다음 곳을 파는 방식이였다면
  너비 우선 탐색은 한 번씩 다 파보고 다 팠으면 두 번씩 다 파보는 방식으로 탐색을 진행한다.

#### 9. 최단 경로 탐색 다익스트라 알고리즘 (Dijkstra Algorithm)

- 다익스트라 알고리즘은 최단 경로를 구한는데에 사용되는 알고리즘이다.
  다익스트라 알고리즘을 구하기 위해서는 일단 구하기 위해 사용될 Weighted Graph
  즉, 가중치 그래프가 필요한데 이것이 그림으로 되어 있으면 편하겠지만 컴퓨터 상으로는 인식이 불가피하니
  연결되어 있는 정점 두 개와 그를 연결하는 간선의 가중치로 되어 있는 리스트를 이용하면 쉽게 구할 수 있다.
  그래프의 방향이 존재할 수도 있고 존재하지 않을 수도 있는데 존재하지 않는 것으로 설명한다.

- 다음은 다익스트라 알고리즘에 사용될 그래프의 리스트이다.

  ```java
  ["AB3", "AC2", "AD4", "BA3", "BD2", "B5F", "CA2", "CE1", "DA4",
  "DB2", "DE1", "DF3", "EC1", "ED1", "EF2", "FB5", "FD3", "FE2"]
  ```

- 이 리스트를 이용해서 다음과 같이 표를 만들 수 있다.

  |       | A    | B    | C    | D    | E    | F    |
  | ----- | ---- | ---- | ---- | ---- | ---- | ---- |
  | **A** | 0 A  | 3 A  | 2 A  | 4 A  | INF  | INF  |
  | **B** |      | 3 A  | 2 A  | 4 A  | 3 C  | INF  |
  | **C** |      | 3 A  |      | 4 A  | 3 C  | 8 B  |
  | **D** |      |      |      | 4 A  | 3 C  | 5 E  |
  | **E** |      |      |      | 4 A  |      | 5 E  |
  | **F** |      |      |      |      |      | 5 E  |

  이를 구하는 과정이 이제 다익스트라 알고리즘이 된다.
  한 번 알아보자.
  일단 이 알고리즘도 DFS와 BFS처럼 임의의 정점을 고르는 것으로 부터 시작된다.
  위의 표는 A를 시작으로 만든 표이다.
  일단 A와 연결되어 있는 B, C, D를 연결된 간선과 어디서 연결되어 있는지 적는다.
  모두 A와 연결되어 있기 때문에 A를 표시하고 각각 3, 2, 4의 가중치를 가지고 있기 때문에 적어준다.
  E와 F는 A와 연결되어 있지 않기 때문에 무한(Infinity)를 표시해준다.
  다음으로 3A, 2A, 4A 중 2가 가장 작으므로 C에서 시작한다.
  C와 연결되어 있는 정점은 A와 E인데 A는 이미 갔다왔으므로 제외하고 E만 보면 된다.
  C에서 E는 3의 가중치가 붙어있는데 이를 위의 INF와 비교해서 가장 최단 값을 구해야 하므로
  더 작은 값을 고른다. 3 < INF 이므로 3과 C에서 왔으니 3 C를 적어준다.
  다음으로 넘어가는데 이렇게 사용된 E와 확정된 A를 제외하고는 적지 않았으니 그대로 적어준다.
  다시 다음으로 넘어가면 3, 4, 3, INF 중 3이 가장 작은데 3이 두 개이다. 이렇게 중복된 경우에는
  아무거나 해도 상관 없다. 이름 순서대로 하자면 B부터 시작한다.
  B는 A, D, F와 연결되어 있고 A는 이미 했으므로 D와 F만 확인한다.
  B에서 D는 가중치가 2이다. 하지만 4 A가 적혀 있는 이유는 4 A는 시작점인 A에서부터 4밖에 걸리지 않지만,
  B에서 D는 그 전에 A에서 B가 3이기 때문에 3 + 2 하여 5이므로 A에서 가는 4가 더 빠른 것이다.
  그래서 바뀌지 않았다. B에서 F는 5가 걸리는데 A에서 B까지 3이므로 5 + 3 인 8 B가 적힌다.
  4, 3, 8 중 3이 가장 작으므로 E부터 시작한다. E는 C, D, F와 연결되어 있고 C는 이미 했으므로
  D와 F만 확인한다.
  E -> D는 1이 걸리고 이전에 4인데 E가 3이므로 3 + 1 == 4이므로 같기 때문에 굳이 변환시킬 필요가 없으므로
  가만히 둔다. E -> F는 2인데 3 + 2 < 8 이므로 5로 변환되어 5 E가 된다.
  4와 5중 4가 더 작으므로 D부터 시작해서 D는 A, B, E, F와 연결되어 있지만 A, B, E는 이미 확정되었으므로
  F만 보면 된다. D -> F는 3이 걸린다. 기존에 D는 4이므로 4 + 3 > 5라서 가만히 둔다.
  이렇게 확정된 표는 위의 표와 같다.

- 이제 이 표를 보는 방법은 다음과 같다.
  걸리는 가중치를 보고 싶은 정점을 정한다.
  만약 E의 가중치를 보고싶다면 '백 트래킹'을 통해서 볼 수 있다.
  백 트래킹은 E가 온 곳을 찾아가면서 처음인 A까지 가는 것을 스택에 넣는 것으로 알 수 있다.

  ```java
  | A | 이렇게 스택에 담긴다.
  | C | 그러면 이들은 pop하면 A -> C -> E가 되는데
  | E | 이게 E로 가는 가장 최단 경로인 것이다.
  -----
  ```

#### 10. 순열 (Permutation)

- 순열은 여러 경우의 수가 있는데 그 경우의 수를 모두 알아야 할 때 사용됩니다.
  만약 서울, 부산, 김해가 있는데 서울 -> 부산 -> 김해도 가능하고 서울 -> 김해 -> 부산도 가능하고
  부산 -> 서울 -> 김해도 가능한 것처럼 모든 경우의 수를 구해야 한다고 할 때 사용되는 것이다.

- 순열은 간단하게 모든 경우의 수를 출력하는 것이 다입니다.
  만약 서울, 부산, 김해가 존재할 때 구하는 방법은 다음과 같습니다.

- 기본인 서울 | 부산 | 김해에서 가장 첫 번째 값을 스와핑한 값들을 구합니다.
  서울과 서울을 스와핑하면 서울 | 부산 | 김해
  서울과 부산을 스와핑하면 부산 | 서울 | 김해
  서울과 김해를 스와핑하면 김해 | 부산 | 서울

  이제 이 결과에서 첫 번째 값은 확정을 시키고 두 번째 값을 스와핑합니다.
  서울 | 부산 | 김해에서 부산과 부산을 스와핑하면 서울 | 부산 | 김해
  서울 | 부산 | 김해에서 부산과 김해를 스와핑하면 서울 | 김해 | 부산
  부산 | 서울 | 김해에서 서울과 서울을 스와핑하면 부산 | 서울 | 김해
  부산 | 서울 | 김해에서 서울과 김해를 스와핑하면 부산 | 김해 | 서울
  김해 | 부산 | 서울에서 부산과 부산을 스와핑하면 김해 | 부산 | 서울
  김해 | 부산 | 서울에서 부산과 서울을 스와핑하면 김해 | 서울 | 부산
  이렇게 총 6 가지의 경우의 수를 모두 출력할 수 있습니다.

#### 11. 비트 연산자 (Bitwise Operator)

- 비트 연산자에는 &(AND 연산자), |(OR 연산자), ^(XOR 연산자), ~(NOT 연산자),
  <<(LEFT SIFT 연산자), >>(RIGHT SIFT 연산자)가 존재한다.
- AND 연산자는 &기호를 사용하며 두 개의 피연산자가 모두 1일 때 즉, 참일 때 1(참)을 리턴한다.
  피연산자가 모두 0이거나 하나라서 0이라면 0을 리턴한다.
- OR 연산자는 |기호를 사용하며 두 개의 피연산자 중 하나라도 1(참)이라면 1(참)을 리턴한다.
- XOR 연산자는 ^기호를 사용하며 두 개의 피연산자가 서로 다를 경우 1(참)을 리턴한다.
  피연산자 둘이 모두 0이거나 모두 1이면 0을 리턴한다.
- NOT 연산자는 ~기호를 사용하며 피연산자가 하나이다.
  그 피연산자가 1이라면 0을 리턴하고 0이라면 1을 리턴한다.
- LEFT SIFT 연산자는 <<기호를 사용하며 숫자 1의 비트는 0001이다.
  이 때 <<2 연산을 시키면 왼쪽으로 비트를 두 칸 옮기라는 뜻으로 0100이 된다.
- RIGHT SIFT 연산자는 >>기호를 사용하며 숫자 4의 비트는 0100이다.
  이 때 >>2 연산을 시키면 오른쪽으로 비트를 두 칸 옮기라는 뜻으로 0001이 된다.

