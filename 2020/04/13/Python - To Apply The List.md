## Python - To Apply The List

#### 1. 리스트에 요소 하나 추가하기

- 리스트에 요소를 하나 추가하는 방법은 append() 메소드를 사용하는 방법이 있다.
  하지만 append() 메소드를 사용하지 않고도 리스트의 요소를 하나 추가하는 두 가지 방법이 존재한다.
  더 있을 수도 있지만 지금 당장은 이것 밖에는 생각이 나지 않는다.

  1. '+' 연산자를 이용하여 요소가 한 개인 리스트와 병합하기

     ```python
     a = [1, 2, 3]
     a += [4]
     print(a)
     
     # [1, 2, 3, 4]
     ```

  2. 슬라이스를 이용하여 요소가 한 개인 리스트 추가하기

     ```python
     a = [1, 2, 3]
     a[len(a):] = [4]
     ```

- 결론적으로 이러한 방법 말고 append() 메소드를 이용해서 요소를 하나 추가할 수 있다.
  append() 메소드는 매개변수를 리스트의 가장 마지막에 추가할 수 있다.

  ```python
  a = [1, 2, 3]
  a.append(4)
  print(a)
  
  # [1, 2, 3, 4]
  ```

- 이전에 있었던 두 가지의 방법보다 append() 메소드가 더 좋은 이유는 성능의 차이가 있다.
  append() 메소드는 리스트에 직접 요소를 추가하는 방법을 사용하지만
  이전의 두 가지 방법은 리스트와 리스트를 병합하여 새로운 리스트를 만들기 때문이다.
  따라서 append() 메소드를 사용하는 것이 훨씬 빠른 성능을 낼 수 있다.

- 참고로 append() 메소드의 매개변수로 요소가 두 개인 리스트를 넣어주면 요소 두 개가 추가되는 것이
  아니라 요소 중 하나가 리스트가 되는 것이다.
  이러한 리스트를 중첩 리스트라고 한다.

  ```python
  a = [1, 2, 3]
  a.append([4, 5])
  print(a)
  
  # [1, 2, 3, [4, 5]]
  ```

#### 2. 리스트 확장하기

- append() 메소드를 이용해서 두 개의 리스트를 합쳐서 확장하려면 모든 요소를 append() 메소드에
  넣어야 하는 불편함이 존재한다.
  그래서 리스트는 append() 메소드 말고도 extend() 메소드를 제공한다.
  extend() 메소드는 매개변수로 리스트를 받아서 중첩된 리스트를 만드는 것이 아니라
  모든 요소를 이어서 하나의 리스트로 만드는 역할을 한다.

  ```python
  a = [1, 2, 3]
  a.extend([4, 5, 6])
  print(a)
  
  # [1, 2, 3, 4, 5, 6]
  ```

- extend() 메소드도 그냥 리스트 두 개를 +연산을 통해 더하는 것과 차이가 있다면
  성능의 차이가 있다고 할 수 있겠다.
  +연산을 통해 리스트를 더하는 것은 새로운 리스트를 생성하는 것이므로 비교적 오래 걸리고
  extend() 메소드는 하나의 리스트에 다른 하나의 리스트의 모든 요소를 추가하는 것이기 때문에
  비교적 빠른 성능을 가진다.

#### 3. 리스트의 인덱스에 요소 추가하기

- 리스트는 append(), extend() 메소드 이외에도 insert() 메소드를 제공한다.
  insert() 메소드는 첫 번째 매개변수로 삽입할 인덱스를 받고
  두 번째 매개변수로 삽입할 요소를 받는다.

  ```python
  a = [1, 2, 3]
  a.insert(1, 'string')
  print(a)
  
  # [1, 'string', 2, 3]
  ```

- insert() 메소드를 사용할 때 인덱스를 정하게 되는데
  만약에 그 인덱스에 값이 존재하면 그 값을 오른쪽으로 한 칸씩 미루고
  그 인덱스에 값을 삽입한다.

- 리스트의 요소가 4개 일 때 인덱스는 0, 1, 2, 3가 존재하는데 4를 지정해도
  오류없이 리스트의 마지막에 추가할 수 있다.

  ```python
  a = [1, 2, 3]
  a.insert(len(a), 'a')
  print(a)
  
  # [1, 2, 3, 'a']
  ```

#### 4. 리스트에서 요소 삭제하기

- 리스트에서 요소를 삭제하는 메소드는 pop() 메소드와 remove() 메소드가 있다.

  ##### 1. pop() 메소드 사용하기

  - pop() 메소드는 매개변수가 존재하지 않을 경우에는 리스트의 가장 마지막 요소를 삭제한다.
    그리고 그 요소를 리턴한다.

    ```python
    a = [1, 2, 3]
    print(a.pop())
    print(a)
    
    # 3
    # [1, 2]
    ```

  - pop() 메소드에 매개변수로 인덱스를 지정할 수도 있다.
    인덱스를 지정하게 되면 그 인덱스에 존재하는 요소를 제거하고 리턴한다.

    ```python
    a = [1, 2, 3]
    print(a.pop(1))
    print(a)
    
    # 2
    # [1, 3]
    ```

  ##### 2. remove() 메소드 사용하기

  - remove() 메소드는 특정 값을 찾아서 삭제하는 메소드이다.
    만약 찾고자하는 값이 두 개 있다면 index 번호가 낮은 값을 삭제한다.
    리턴값은 None이며 삭제하고자 하는 값이 없으면 오류를 발생시킨다.

    ```python
    a = [1, 2, 3]
    print(a.remove(3))
    print(a.remove(2))
    print(a)
    
    # None
    # None
    # [1]
    ```

  ##### 3. del 키워드 사용하기

  - pop(), remove() 메소드를 사용하지 않고 del 키워드를 이용해서
    요소를 삭제하는 방법도 존재한다.

    ```python
    a = [1, 2, 3]
    del a[2]
    del a[0]
    print(a)
    
    # [1]
    ```

#### 5. 리스트에서 값을 이용해 인덱스 구하기

- index() 메소드를 사용하면 리스트에서 매개변수로 된 요소의 인덱스를 반환한다.
  만약 찾고자 하는 값이 두 개 이상 있다면 index가 가장 낮은 값의 인덱스를 반환한다.

  ```python
  a = ['a', 'b', 'c', 'd']
  print(a.index('d'))
  print(a.index('a'))
  
  # 3
  # 0
  ```

- 리스트에 원하는 값이 없으면 오류를 발생시킨다.

#### 6. 리스트에서 특정 값의 갯수 구하기

- count() 메소드를 사용하면 매개변수로 된 요소의 갯수를 리턴한다.

  ```python
  a = ['a', 'a', 'b', 'b', 'a']
  print(a.count('a'))
  print(a.count('b'))
  
  # 3
  # 2
  ```

#### 7. 리스트의 요소의 순서 뒤집기

- reverse() 메소드를 사용하면 리스트안의 요소들의 순서를 완전히 뒤바꿉니다.

  ```python
  a = [10, 'a', 1.1, True, [1, 2]]
  a.reverse()
  print(a)
  
  # [[1, 2], True, 1.1, 'a', 10]
  ```

- 리스트안에 리스트가 있을 경우 안의 리스트의 요소는 순서가 변하지 않는다.

#### 8. 리스트의 요소를 정렬하기

- sort() 메소드를 사용하면 리스트를 정렬하는 것이 가능하다.

  ```python
  a = [4, 6, 2, 0, 10]
  a.sort()
  print(a)
  
  # [0, 2, 4, 6, 10]
  ```

- sort() 메소드에는 reverse라는 속성을 넣을 수 있는데 reverse=True이면 반대로 정렬
  즉, 내림차순으로 정렬할 수 있다.
  reverse=False라면 sort() 메소드와 같은 역할을 하게 된다.

  ```python
  a = [4, 6, 2, 0, 10]
  a.sort(reverse=True)
  print(a)
  a.sort(reverse=False)
  print(a)
  
  # [10, 6, 4, 2, 0]
  # [0, 2, 4, 6, 10]
  ```

- sort() 메소드를 사용할 때는 리스트에 float, int, bool 타입만 안에 있어야 한다.
  리스트나, 문자열, 튜플이 요소로 존재하는 상태에서 sort() 메소드를 실행하면 오류가 발생한다.

- 1.0과 1, True는 같은 것으로 취급하며 이것들끼리는 정렬이 안 될 수도 있다.
  0과 0.0, False는 같은 것으로 취급하며 이것들끼리는 정렬이 안 될 수도 있다.

- sort() 메소드 말고 sorted() 메소드도 존재하는데 sort() 메소드는 기존의 리스트를 정렬하는 반면,
  sorted() 메소드는 리스트를 정렬해서 새로운 리스트를 생성한다.

#### 9. 리스트의 모든 요소를 삭제하기

- clear() 메소드를 사용하면 리스트를 빈 리스트로 만들 수 있다.

  ```python
  a = [1, 1, 1, 1, 1, 1, ... , 1, 1, 1, 1, 1]
  a.clear()
  print(a)
  
  # []
  ```

- 슬라이스 기능을 이용해서 모든 요소를 삭제하는 방법도 존재한다.

  ```python
  a = [1, 1, 1, 1, 1, 1, ... , 1, 1, 1, 1, 1]
  del a[:]
  print(a)
  
  # []
  ```

#### 10. 리스트의 복사

- 리스트를 대입으로 복사하는 경우에는 하나의 리스트가 존재하는데 그 리스트를 가리키는 변수가
  두 개가 되는 것이다.
  따라서 두 리스트를 is로 비교해보면 True가 나오게 된다.
  가리키는 것이 같기 때문이다.

  ```python
  a = [1, 2, 3]
  b = a;
  
  print(a)
  print(b)
  print(a is b)
  print(a == b)
  
  # [1, 2, 3]
  # [1, 2, 3]
  # True
  # True
  ```

- 그러면 두 리스트를 완전히 다른 것으로 분리하려면 어떻게 해야할까?
  첫 번째 방법은 list() 함수를 이용해서 완전히 새로운 리스트를 만드는 방법이고
  두 번째 방법은 copy() 메소드를 이용해서 깊은 복사를 실행하는 방법이다.

  ```python
  a = [1, 2, 3]
  b = list(a)
  print(a is b)
  print(a == b)
  
  # False
  # True
  
  c = [1, 2, 3]
  d = c.copy()
  print(a is b)
  print(a == b)
  
  # False
  # True
  ```

- is 연산자를 사용할 경우 가리키는 리스트가 다르므로 False이고
  == 연산자를 사용할 경우에는 두 리스트의 값은 같으므로 True이다.

#### 11. 인덱스와 요소를 같이 출력하기

- 반복문을 통해서 리스트의 요소를 출력할 때 우리는 다음과 같이 사용할 수 있다는 것을 배웠다.

  ```python
  a = ['apple', 'banana', 'melon', 'grape', 'orange']
  for i in a:
      print(i)
      
  # apple
  # banana
  # melon
  # grape
  # orange
  ```

- 그러면 인덱스도 같이 사용하고 싶다면 어떻게 해야할까?
  그럴 땐 enumerate()를 사용하면 된다.
  enumerate()를 사용하면 인덱스와 요소(값), 이렇게 두 개의 값을 얻을 수 있다.

  ```python
  a = ['apple', 'banana', 'melon', 'grape', 'orange']
  for i, v in enumerate(a):
      print('a[' + str(i) + '] : ' + str(v))
  
  # a[0] : apple
  # a[1] : banana
  # a[2] : melon
  # a[3] : grape
  # a[4] : orange
  ```

- 첫 번째 값인 i가 인덱스이고 두 번째 값인 v가 꺼내온 요소이다.
  그런데 enumerate()를 사용하지 않고도 인덱스와 요소 모두 사용하는 법이 있다.

  ```python
  a = ['apple', 'banana', 'melon', 'grape', 'orange']
  for i in range(len(a)):
      print('a[' + str(i) + '] : ' + str(a[i]))
      
  # a[0] : apple
  # a[1] : banana
  # a[2] : melon
  # a[3] : grape
  # a[4] : orange
  ```

#### 12. 리스트 표현식을 이용해서 리스트 생성하기

- 리스트 표현식은 다음과 같다.

  ```python
  i for i in range(n)
  ```

- 이를 이용해서 다음과 같이 리스트를 생성할 수 있다.

  ```python
  a = [i for i in range(5)]
  print(a)
  
  b = [i*2 for i in range(5)]
  print(b)
  
  # [0, 1, 2, 3, 4]
  # [0, 2, 4, 6, 8]
  ```

  ##### 12-1 표현식 안에 if문 사용하기

  - 리스트 표현식에 if문을 추가한 문장은 다음과 같다.

    ```python
    i for i in range(n) if ...
    ```

  - 이러면 range() 에서 나온 i가 if문을 만족한 경우에만 나오게 된다.

    ```python
    a = [i for i in range(10) if i % 2 == 0]
    print(a)
    
    # [0, 2, 4, 6, 8]
    ```

  ##### 12-2 표현식 안에 여러 개의 for문과 여러 개의 if문 사용하기

  - 지금까지 표현식을 사용할 때 for문과 if문을 한 번씩 사용해보았다.
    하지만 for문과 if문을 여러 개 사용할 수 있다.

    ```python
    a = [str(i)+str(j)+str(k)   for k in range(1, 3)
                                for j in range(1, 3)
                                for i in range(1, 3)]
    print(a)
    
    # ['111', '211', '121', '221', '112', '212', '122', '222']
    ```

  - 이렇게 표현식 안에 여러 개의 for문이 존재할 경우에는 가장 뒤에 있는 for문부터 작동한다.
    따라서 111, 211 이렇게 i가 증가했던 것이고
    다음에는 j를 사용하는 for문이 작동하고 다음으로 k가 작동한다.

  - 이제 이 for문마다 if문이 모두 붙을 수 있다.

#### 13. 리스트에 map() 사용하기

- map() 함수는 어떠한 자료형으로 매핑하는 역할을 한다.

  ```python
  a = [1.1, 2.2, 3.3]
  a = list(map(int, a))
  print(a)
  
  # [1, 2, 3]
  ```

- input() 함수를 사용하면 입력을 받는데 입력은 모두 문자열로 만들어진다.
  input().split() 과 같이 입력받으면 구분자를 기준으로 리스트가 만들어진다.
  이를 바로 매핑하기 위해선 다음과 같이 한다.

  ```python
  a = map(int, input('입력\n').split())
  print(a)
  
  # 입력
  ### 10 20 30
  # [10, 20, 30]
  ```

#### 14 max() min() sum()

- max() 함수는 리스트에 포함된 숫자 중에서 가장 큰 수를 리턴한다.
  min() 함수는 리스트에 포함된 숫자 중에서 가장 작은 수를 리턴한다.
  sum() 함수는 리스트에 포함된 숫자를 모두 더한 합을 리턴한다.



#### 15 Tuple

- 튜플은 변경이 안 되기 때문에 append(), extend() 메소드가 불가능하다.
  하지만 index(), count(), max(), min(), sum() 함수는 사용이 가능하다.
  또한 표현식도 리스트와 동일하게 사용이 가능하다.